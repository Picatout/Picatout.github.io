<!doctype html>
<html>
<header>
<title>machine virtuelle du VPC-32V</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="Author" content="Jacques Deschênes">
<meta name="Created on" content="2018-05-25">
<meta name="version" content="1.0">
<meta name="licence" content="CC-NC-SA-BY V3.0">
<link rel="stylesheet" type="text/css" href="style.css">
</header>
<body>
<h2>machine virtuelle du VPC-32V</h2>
<h4>Licence</h4>
<p>  
  Ce document fait partie du projet <a href="https://github.com/picatout/pv16sog">PV16SOG</a> et est fourni sous licence 
  <a href="https://creativecommons.org/">CC-NC-SA-BY V3.0</a><br><br>
  <b>auteur:</b> Jacques Deschênes<br>
  <b>révision</b> 1.0</br>
  <b>Copyright:</b> 2015,2016, Jacques Deschênes<br>	

</p>
<h3></a>Présentation</h3>
<p>
	L'ordinateur VPC-32V possède un interpréteur BASIC qui exécute du bytecode sur une machine virtuelle à piles. Ce document décris cette
	machine virtuelle. 
</p>
<p>
	L'interpréteur vpcBASIC ecris en <b>C</b> commence par compiler le code source BASIC en bytecode pour cette machine virtuelle ensuite appelle la fonction<br>
	<b>int StackVM(const uint8_t* prog_space)</b><br> 
	qui est une fonction écrite en assembleur dans le fichier <b>vm.S</b>.<br>
	<b>prog_space</b> est la mémoire RAM allouée par l'interpréteur vpcBASIC où il compile le bytecode.
</p>
<h4>Architecture</h4>
<p>
	Cette machine virtuelle utilise les 9 registres <b>S0 à S8</b> du PIC32MX170F256B pour ses états internes ainsi que 2 piles. la première pile <i>dstack</i>
	est utilisée pour les arguments et la deuxième <i>rstack</i> est utilisée pour conserver les adresses de retours des sous-programmes ainsi que
	pour sauvegarder les registres <i>step</i> et <i>limit</i> lors de l'imbrication de boucles <b>FOR</b>. Les registres de la machine virtuelle
	sont les suivants:
	<ul>
	<li><b>S0</b> <i>ip</i>, pointeur d'instruction. Les instructions sont de longueur variable mais les opcodes sont encodés sur 8 bits.</li>
	<li><b>S1</b> <i>dp</i>, pointeur pour la pile <i>dstack</i></li>
	<li><b>S2</b> <i>rp</i>, pointeur pour la pile <i>rstack</i></li>
	<li><b>S3</b> <i>w</i>, pointeur de travail.</li>
	<li><b>S4</b> <i>T</i>, sommet de la pile dstack.</li>
	<li><b>S5</b> <i>R</i>, sommet de la pile rstack.</li>
	<li><b>S6</b> <i>limit</i>, Ce registre est utilisé par les boucles <b>FOR</b> et correspond à la limite du compteur de boucle.</li>
	<li><b>S7</b> <i>step</i>, Ce registre est utilisé par les boucles <b>FOR</b> et correspond à la valeur <b>STEP</b> de la boucle 
	<b>FOR</b>.</li>
	<li><b>S8</b> <i>frame</i>, pointeur pour les paramètres et variables locales qui sont sur la pile <i>dstack</i></li>
	</ul>
</p>
<p>
	les piles <b>dstack</b> et <b>rstack</b> peuvent contenir 256 éléments de 32 bits appellé <b>cellule</b>. Étant donné ces tailles 
	limités il faut-être prudent dans l'utilisation des fonctions récursives.
</p>
<h4><a name="opcodes"></a>codes machines</h4>
<p>
	Cette table contient la description de chacun des codes  machine (opcode) utilisés par la machine virtuelle. La notation <i>état stack</i>
	est une illustration de l'état de la pile <I>dstack</I> ou <i>rstack</i> avant et après l'exécution de cette instruction.
	<table border="single">
	<tr><th>opcode</th><th>mnémonique</th><th>description</th><th>état stacks</th></tr>
	<tr><td>0</td><td>BYE</td><td>Termine l'exécution du programme et sortie de la machine virtuelle. La machine virtuelle retourne un 
	code d'erreur ou 0 s'il n'y a pas d'erreur. Consulter les fichiers <b>basic.c</b> et <b>basic.h</b> pour plus d'information sur
	ces codes d'erreurs. La commande BASIC <b>BYE</b> appelle cet opcode.</td><td>( -- )</td></tr>
	<tr><td>1</td><td>ABORT</td><td>Exécuté lorsque la machine virtuelle rencontre une erreur interne. Mais fin à l'exécution du programme avec sortie
	de stackVM avec un code d'erreur.</td><td>( j*x -- j*x )</td></tr>
	<tr><td>2</td><td>LIT</td><td>Entier litéral 32 bits. L'entier suit l'opcode et est empilé au sommet de la pile.</td><td>( -- n)</td></tr>
	<tr><td>3</td><td>WLIT</td><td>Entier litéral 16 bits. L'entier suit l'opcode et est empilé au sommet de la pile.</td><td>( -- n)</td></tr>
	<tr><td>4</td><td>CLIT</td><td>Entier litéral 8 bits. L'entier suit l'opcode et est empilé au sommet de la pile.</td><td>( -- n)</td></tr>
	<tr><td>5</td><td>BRA</td><td>Branchement relatif inconditionnel. L'offset de 16 bits signé suis le opcode. IP=IP+offset</td><td>( -- )</td></tr> 
	<tr><td>6</td><td>?BRA</td><td>Branchement relatif conditionnel à f<>0.L'offset de 16 bits signé suis le opcode. IP=IP+offset </td><td>( f -- )</td></tr>
	<tr><td>7</td><td>!</td><td>Sauvegarde T dans une variable 32 bits. <i>var=n</i></td><td>( n adr -- )</td></tr>
	<tr><td>8</td><td>@</td><td>Empile la variable entier 32 bits dont l'adresse est au sommet de la pile.</td><td>( adr -- n )</td></tr>
	<tr><td>9</td><td>C!</td><td>Sauvegarde une variable entier 8 bits. <i>var#=c</i></td><td>( c adr -- )</td></tr>
	<tr><td>10</td><td>C@</td><td>Empile la variable entier 8 bits dont l'adresse est au sommet de la pile.</td><td>( adr -- c )</td></tr>
	<tr><td>11</td><td>DROP</td><td>Jette l'élément au sommet de la pile <i>dstack</i>.</td><td>( n -- )</td></tr>
	<tr><td>12</td><td>DUP</td><td>Clone le sommet de la pile <i>dstack</i></td><td>( n -- n n )</td></tr>
	<tr><td>13</td><td>SWAP</td><td>Interchange les 2 éléments au sommet de <I>dstack</I></td><td>( n1 n2 -- n2 n1 )</td></tr>
	<tr><td>14</td><td>OVER</td><td>Copie le 2ième élément de la pile <i>dstack</i> au sommet.</td><td>( n1 n2 -- n1 n2 n1 )</td></tr>
	<tr><td>15</td><td>PICK</td><td>Copie le nième élément de la pile <i>dstack</i> au sommet.</td><td>( n1 n2...nx ... ox -- n1 n2 ... nx ... nx )</td></tr>
	<tr><td>16</td><td>INVERT</td><td>négation arithmétique du sommet de la pile.</td><td>( n -- -n )</td></tr>
	<tr><td>17</td><td>+</td><td>Addition</td><td>( n1 n2 -- n1+n2 )</td></tr>
	<tr><td>18</td><td>-</td><td>Soustraction</td><td>( n1 n2 -- n1-n2 )</td></tr>
	<tr><td>19</td><td>*</td><td>Multiplication entière</td><td>( n1 n2 -- n1*n2 )</td></tr>
	<tr><td>20</td><td>/</td><td>Division entière</td><td>( n1 n2 -- n1/n2 )</td></tr>
	<tr><td>21</td><td>MOD</td><td>Modulo</td><td>( n1 n2 -- n1%n2 )</td></tr> 
	<tr><td>22</td><td>0&lt;</td><td>Si T<0 f=-1 sinon f=0</td><td>( n1 n2 -- f )</td></tr>
	<tr><td>23</td><td>0=</td><td>Si T==0 f=-1 sinon f=0</td><td>( n1 n2 -- f )</td></tr>
	<tr><td>24</td><td>&</td><td>Fonction binaire ET.</td><td>( n1 n2 -- n1&n2 )</td></tr>     
	<tr><td>25</td><td>|</td><td>Fonction binaire OU inclusif.</td><td>( n1 n2 -- n1|n2 )</td></tr>
	<tr><td>26</td><td>^</td><td>Fonction binaire OU exclusif.</td><td>( n1 n2 -- n1^n2 )</td></tr>
	<tr><td>27</td><td>!</td><td>Remplace l'entier au sommet de la pile par son complément à 1</td><td>( n -- ~n )</td></tr>
	<tr><td>28</td><td>NOT</td><td>négation booléenne. Si f1 est faux alors f2=vrai sinon f2=faux.</td><td>( f1 -- f2 )</td></tr>
	<tr><td>29</td><td>OR</td><td>OU booléen. Si f1 ou f2 est vrai alors f3=vrai sinon f3=faux.</td><td>( f1 f2 -- f3 )</td></tr>
	<tr><td>30</td><td>AND</td><td>ET booléen. Si f1 et f2 sont vrai alors f3=vrai sinon T=faux.</td><td>( f1 f2 -- f3 )</td></tr>
	<tr><td>31</td><td>TICKS</td><td>Empile la valeur de la variable système <i>systicks</i></td><td>(  -- u )</td></tr>
	<tr><td>32</td><td>SLEEP</td><td>suspend l'exécution du programme pour <b>u</b> millisecondes.</td><td>( u --  )</td></tr>
	<tr><td>33</td><td>?DUP</td><td>Clone le sommet de la pile <i>dstack</i> si différent de zéro.</td><td>( n -- 0 | n n )</td></tr>
	<tr><td>34</td><td>1+</td><td>Incrémente le sommet de la pile.</td><td>( n -- n+1 )</td></tr>
	<tr><td>35</td><td>1-</td><td>Décrément le sommet de la pile</td><td>( n -- n-1 )</td></tr>
	<tr><td>36</td><td>+!</td><td>Incrémente la variable à l'adresse <b>adr</b> de la valeur <b>n</b>.</td><td>( n adr --  )</td></tr>
	<tr><td>37</td><td>ROT</td><td>Rotation horaire des 3 éléments au sommet de <i>dstack</i>.</td><td>( n1 n2 n3 -- n2 n3 n1 )</td></tr>
	<tr><td>38</td><td>-ROT</td><td>Rotation anti-horaire des 3 éléments au sommet de <i>dstatck</i>.</td><td>( n1 n2 n3  -- n3 n1 n2 )</td></tr>
	<tr><td>39</td><td>MIN</td><td>Conserve le plus petit de <b>n1</b> et <b>n2</b></td><td>( n1 n2 -- n )</td></tr>
	<tr><td>40</td><td>MAX</td><td>Conserve le plus grand de <b>n1</b> et <b>n2</b></td><td>( n1 n2 -- n )</td></tr>
	<tr><td>41</td><td>ABS</td><td>Remplace l'entier <b>n</b> par sa valeur absolue.</td><td>( n -- u )</td></tr>
	<tr><td>42</td><td>LSHIFT</td><td>Décale vers la gauche l'entier <b>n</b> de <b>u</b> bits.</td><td>( n u -- n )</td></tr>
	<tr><td>43</td><td>RSHIFT</td><td>Décale vers la droite l'entier <b>n</b> de <b>u</b> bits.</td><td>( n u -- n )</td></tr>
	<tr><td>44</td><td>0BRA</td><td>Branchement relatif de 16 bits si <b>n</b>==0. Le déplacement suis l'opcode.</td><td>( n --  )</td></tr>
	<tr><td>45</td><td>DCNT</td><td>Empile le nombre d'éléments sur <i>dstack</i></td><td>(  -- u )</td></tr>
	<tr><td>46</td><td>=</td><td>Compare <b>n1</b> et <b>n2</b> pour l'égalité</td><td>( n1 n2 -- f )</td></tr>
	<tr><td>47</td><td>&lt;&gt;</td><td>Compare <b>n1</b> et <b>n2</b>, retourne vrai si différents.</td><td>( n1 n2 -- f )</td></tr>
	<tr><td>48</td><td>&lt;</td><td>f=n1&lt;n2</td><td>( n1 n2 -- f )</td></tr>
	<tr><td>49</td><td>&gt;</td><td>f=n1&gt;n2</td><td>( n1 n2 -- f )</td></tr>
	<tr><td>50</td><td>&lt;=</td><td>f=n1&lt;=n2</td><td>( n1 n2 -- f )</td></tr>
	<tr><td>51</td><td>&gt;=</td><td>f=n1&gt;=n2</td><td>( n1 n2 -- f )</td></tr>
	<tr><td>52</td><td>FOR&gt;R</td><td>Sauvegarde de <i>limit</i> et <i>step</i> sur <i>rstack</i></td><td>( R:  -- limit step )</td></tr>
	<tr><td>53</td><td>R&gt;FOR</td><td>Restaure <i>limit</i> et <i>step</i> à partir de <i>rstack</i></td><td>( limit step --  )</td></tr>
	<tr><td>54</td><td>FOR</td><td>Initialisation de <i>limit</i> et <i>step</i> pour la boucle FOR...NEXT</td><td>( limit step --  )</td></tr>
	<tr><td>55</td><td>FOR?</td><td>Compare <b>n</b> à <i>limit</i> pour dépassement. f=vrai si n&gt;<i>limit</i>.</td><td>( n -- f )</td></tr>
	<tr><td>56</td><td>FORNEXT</td><td>Incrément la variable de contrôle de la boucle FOR...NEXT avec la valeur de <i>step</i>.
	L'adresse de la variable est au sommet de <i>dstack</i>.</td><td>( adr --  )</td></tr>
	<tr><td>57</td><td>RANDOMIZE</td><td>Initialize le générateur pseudo-hasard en utilisant <i>systicks</i>.</td><td>(  --  )</td></tr>
	<tr><td>58</td><td>RND</td><td>Empile un entier pseudo-aléatoire entre 0 et MAXINT.</td><td>(  -- u )</td></tr>
	<tr><td>59</td><td>KEY</td><td>Attend réception d'un caractère de la console.</td><td>(  -- c )</td></tr>
	<tr><td>60</td><td>KEY?</td><td>Vérifie s'il y a un caractère dans la file du clavier console. Retourne le caractère
	disponible ou 0.</td><td>(  -- 0|c )</td></tr>
	<tr><td>61</td><td>EMIT</td><td>Envoie à la console le caractère <b>c</b>.</td><td>( c --  )</td></tr>
	<tr><td>62</td><td>PSTR</td><td>Envoie à la console la chaîne imbriquée dans le code à la suite de ce opcode.</td><td>(  --  )</td></tr>
	<tr><td>63</td><td>CR</td><td>Envoie à la console une commande de retour à la ligne</td><td>(  --  )</td></tr>
	<tr><td>64</td><td>.</td><td>Imprime sur la console l'entier <b>n</b></td><td>( n --  )</td></tr>
	<tr><td>65</td><td>TYPE</td><td>Imprime sur la console la chaîne située à l'adresse <b>adr</b></td><td>( adr --  )</td></tr>
	<tr><td>66</td><td>SPACES</td><td>Imprime sur la console <b>n</b> espaces.</td><td>( n --  )</td></tr>
	<tr><td>67</td><td>SOUND</td><td>Fait entendre une tonalité de fréquence <b>u1</b> et de durée <b>u2</b> millisecondes.</td><td>( u1 u2 --  )</td></tr>
	<tr><td>68</td><td>BEEP</td><td>Fait entendre une tonalitée brève de 1000 hertz.</td><td>( -- )</td></tr>
	<tr><td>69</td><td>PLAY</td><td>Joue une mélodie dont le code est à l'adresse <b>adr</b>. Voir la commande BASIC PLAY.</td><td>( adr --  )</td></tr>
	<tr><td>70</td><td>CLS</td><td>Vide l'écran de la console et positionne le curseur texte dans le coin supérieur gauche.</td><td>(  --  )</td></tr>
	<tr><td>71</td><td>UBOUND</td><td>Empile la grandeur de la variable tableau à l'adresse <b>adr</b></td><td>( adr -- u )</td></tr>
	<tr><td>72</td><td>LC!</td><td>Sauvegarde la variable locale dont la position suit cet opcode. Les variables locales sont conservées
	sur <i>dstack</i>. L'opcode est suivit de la position de la variable relativement au pointeur <i>frame</i>.</td><td>( n --  )</td></tr>
	<tr><td>73</td><td>LC@</td><td>Empile la variable locale dont la position suit cet opcode.  Les variables locales sont conservées
	sur <i>dstack</i>. L'opcode est suivit de la position de la variable relativement au pointeur <i>frame</i>.</td><td>(  -- n )</td></tr>
	<tr><td>74</td><td>LCADR</td><td>Empile l'adresse absolue d'une variable locale dont l'offset suit cet opcode.</td><td>(  -- adr )</td></tr>
	<tr><td>75</td><td>FRAME</td><td>Sauvegarde <i>frame</i> sur <i>rstack</i> et l'initialise avec la nouvelle valeur. 
	Un octet suit le opcode pour indiquer le nombre de cellules qui ont été réservées sur <i>dstack</i> pour les arguments de la fonction. 
	<i>frame</i> pointe le premier argument. Cet opcode précède un <b>CALL</b></td><td>(R:  -- frame )</td></tr>
	<tr><td>76</td><td>CALL</td><td>Appel la sous-routine à l'adresse <i>adr</i>. Sauvegarde <i>ip</i> sur <i>rstack</i> et initialise
	<i>ip</i> avec <i>adr</i>.</td><td>( adr --  )<br>(R: -- ip)</td></tr>
	<tr><td>77</td><td>LEAVE</td><td>Sortie de sous-routine. Transfert <i>frame</i> dans <i>dp</i> pour libérer les arguments et
	variables locales <i>j*n</i>q ui étaient utilisées par cette sous-routine. Dépile <i>rstack</i> dans <i>ip</i> et ensuite dans
	<i>frame</i> </td><td>( j*n --  )<br>(R: frame ip -- )</td></tr>
	<tr><td>78</td><td>LOCAL</td><td>Cet opcode viens à la suite d'un <b>CALL</b>. Ajuste <i>dp</i> pour réserver sur <i>dstack</i> 
	l'espace pour les variables locales. Le nombre 	de cellules à réserver est un octet qui suit l'opcode. 
	<i>j*n</i> représente les cellules supplémentaires réservées sur <i>dstack</i>.
	</td><td>(  -- j*n )</td></tr>
	<tr><td>79</td><td>TRACE</td><td>Activation de l'outil de débogage <a href="#trace">TRACE</a>. Voir la discription plus bas. <b>n</b> indique le
	mode de débogage.</td><td>( n --  )</td></tr>
	<tr><td>80</td><td>$ADR</td><td>Empile l'adresse de la chaîne imbriquée dans le code à la suite de cet opcode.
	Après exécution de cet instruction <i>ip</i> pointe l'opcode qui suit immédiatement la chaîne.</td><td>(  -- adr )</td></tr>
	<tr><td>81</td><td>LEN</td><td>Retourne la longueur de la chaîne <i>adr</i>.</td><td>( adr -- u )</td></tr>
	<tr><td>82</td><td>READLN</td><td>Lecture d'une ligne à partir de la console. <b>adr</b> est l'adresse du tampon qui doit recevoir les caractères.
	<b>n1</b> est la longueur du tampon. <b>n2</b> est la longueur de la chaîne lue.
	</td><td>(  adr n1 -- adr n2 )</td></tr>
	<tr><td>83</td><td>VAL</td><td>Convertie la chaîne en nombre.</td><td>( adr -- n )</td></tr>
	<tr><td>84</td><td>VALLOC</td><td>Alloue <b>n</b> octets dans l'espace réservé aux variables BASIC. <i>adr</i> est l'adresse 
	de l'espace allouée</td><td>(  -- adr )</td></tr>
	<tr><td>85</td><td>$ALLOC</td><td>Alloue une chaîne dynamique de longueur <b>n</b>. <i>adr</i> est l'adresse de l'espace alloué.</td><td>(  -- adr )</td></tr>
	<tr><td>86</td><td>$FREE</td><td>Libère une chaîne allouée dynamiquement. <i>adr</i> est l'adresse retournée par $ALLOC</td><td>( adr --  )</td></tr>
	<tr><td>87</td><td>$FREE</td><td></td><td>(  --  )</td></tr>
	<tr><td>88</td><td>$FREENOTREF</td><td>Libère la chaîne <i>adr</i> seulement si elle n'est pas référencée. </td><td>( adr --  )</td></tr>
	<tr><td>89</td><td>$CPY</td><td>Copie la chaîne <i>src</i> dans <i>dest</i>.</td><td>( src dest -- dest )</td></tr>
	<tr><td>90</td><td>CURLINE</td><td>Retourne la ligne sur laquelle se trouve le curseur texte.</td><td>(  -- n )</td></tr>
	<tr><td>91</td><td>CURCOL</td><td>Retourne la colonne sur laquelle se trouve le curseur texte.</td><td>(  -- n )</td></tr>
	<tr><td>92</td><td>LOCATE</td><td>Posistion le curseur texte à <i>ligne</i>, <i>col</i>.</td><td>( ligne col --  )</td></tr>
	<tr><td>93</td><td>BTEST</td><td>Retourne la valeur du bit <b>b</b> de l'entier <b>n</b></td><td>( n b -- 0|1 )</td></tr>
	<tr><td>94</td><td>SETTMR</td><td>Initialize la minuterie à <b>u</b> millisecondes.</td><td>( u --  )</td></tr>
	<tr><td>95</td><td>TIMEOUT</td><td>Vérifie si la minuterie est expirée.</td><td>(  -- f )</td></tr>
	<tr><td>96</td><td>INVERTVID</td><td>Sélectionne le mode vidéo. <b>0</b> blanc/noir, <b>1</b> noir/blanc</td><td>( 0|1 --  )</td></tr>
	<tr><td>97</td><td>SCRLDN</td><td>Glisse l'écran console d'une ligne texte vers le bas, laissant la ligne du haut vide.</td><td>(  --  )</td></tr>
	<tr><td>98</td><td>SCRLUP</td><td>Glisse l'écan console d'une ligne vers le haut, laissant la ligne du bas vide.</td><td>(  --  )</td></tr>
	<tr><td>99</td><td>INSERLN</td><td>Insère une ligne vide là où le curseur texte se trouve. Positionne le curseur au 
	début de la ligne.</td><td>(  --  )</td></tr>
	<tr><td>100</td><td>PGET</td><td>Obtient la valeur du pixel du moniteur VGA aux coordonnées {x,y}.</td><td>( x y -- 0|1 )</td></tr>
	<tr><td>101</td><td>PSET</td><td>Fixe l'état du pixel du moniteur VGA aux coordonées {x,y} à l'état <i>p</i>.</td><td>( x y p --  )</td></tr>
	<tr><td>102</td><td>PXOR</td><td>Inverse l'état du pixel du moniteur VGA aux coordonnées {x,y}.</td><td>( x y --  )</td></tr>
	<tr><td>103</td><td>LINE</td><td>Trace une ligne entre les points <b>{x0,y0}</b> et <b>{x1,y1}</b>.</td><td>( x0 y0 x1 y1 --  )</td></tr>
	<tr><td>104</td><td>RECT</td><td>Desssine un rectangle, <b>{x,y}</b> coin supérieur gauche. <b>w</b> largeur, <b>h</b> hauteur</td><td>( x y w h --  )</td></tr>
	<tr><td>105</td><td>BOX</td><td>Dessine une boite, <b>{x,y}</b> coin supérieur gauche. <b>w</b> largeur, <b>h</b> hauteur</td><td>(  --  )</td></tr>
	<tr><td>106</td><td>CIRCLE</td><td>Dessine un cercle de centre <b>{x,y}</b> et de rayon <b>r</b></td><td>( x y r --  )</td></tr>
	<tr><td>107</td><td>ELLIPSE</td><td>Dessine une ellipse circonscrite dans le rectangle.</td><td>( x0 y0 x1 y1  --  )</td></tr>
	<tr><td>108</td><td>POLYGON</td><td>Dessine un polygon. Voir la commande BASIC correspondante.</td><td>( adr n --  )</td></tr>
	<tr><td>109</td><td>FILL</td><td>Remplie une figure fermée. Voir la commande BASIC correspondante.</td><td>( x y --  )</td></tr>
	<tr><td>110</td><td>SPRITE</td><td>Dessine un sprite. Voir la commande BASIC correspondante.</td><td>( adr w h --  )</td></tr>
	<tr><td>111</td><td>VGACLS</td><td>Vide l'écran du moniteur VGA.</td><td>(  --  )</td></tr>
	<tr><td>112</td><td>SRCLEAR</td><td> Voir la commande BASIC correspondante.</td><td>( adr size --  )</td></tr>
	<tr><td>113</td><td>SRREAD</td><td> Voir la commande BASIC correspondante.</td><td>( adr_ram adr_v size --  )</td></tr>
	<tr><td>114</td><td>SRWRITE</td><td> Voir la commande BASIC correspondante.</td><td>( adr_ram adr_v size --  )</td></tr>
	<tr><td>115</td><td>SAVESCR</td><td> Voir la commande BASIC correspondante.</td><td>( adr --  )</td></tr>
	<tr><td>116</td><td>RESTSCR</td><td> Voir la commande BASIC correspondante.</td><td>( adr --  )</td></tr>
	<tr><td>117</td><td>SRLOAD</td><td> Voir la commande BASIC correspondante.</td><td>( addr_ram char* -- size )</td></tr>
	<tr><td>118</td><td>SRSAVE</td><td> Voir la commande BASIC correspondante.</td><td>( addr_ram char* size -- exit_code )</td></tr>

	<tr><td></td><td></td><td></td><td>(  --  )</td></tr>
	</table>
</p>
<h3><a name="trace"></a>Outil de débogage TRACE</h3>
<p>
</p>
<hr width="50%" align="center">
<h2>INDEX</h2>
<p>
	<ul>
		<li><a href="./index.html">Introduction</a></li>
		<li><a href="./vpc32vga.html">Description du VPC-32V</a></li>
		<li><a href="./shell.html">shell du VPC-32V</a></li>
		<li><a href="./editor.html">Éditeur du VPC-32V</a></li>
        <li><a href="./BASIC.html">BASIC du VPC-32V</a></li>
        <li><a href="./stackvm.html">machine virtuelle du VPC-32V</a></li>
	</ul>
</p>
/body>
</html>
