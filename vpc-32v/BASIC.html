<!doctype html>
<html>
<header>
<title>BASIC du VPC-32V</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="Author" content="Jacques Deschênes">
<meta name="Created on" content="2018-05-25">
<meta name="version" content="1.0">
<meta name="licence" content="CC-NC-SA-BY V3.0">
<link rel="stylesheet" type="text/css" href="style.css">
</header>
<body>
<h2>Langage BASIC du VPC-32V</h2>
<h4>Licence</h4>
<p>  
  Ce document fait partie du projet <a href="https://github.com/picatout/vpc-32vga">VPC-32V</a> et est fourni sous licence 
  <a href="https://creativecommons.org/">CC-NC-SA-BY V3.0</a><br><br>
  <b>auteur:</b> Jacques Deschênes<br>
  <b>révision</b> 1.0</br>
  <b>Copyright:</b> 2013-2018, Jacques Deschênes<br>	

</p>
<h3></a>Présentation</h3>
<p>
	L'ordinateur VPC-32V possède un interpréteur BASIC inspiré de QBASIC mais n'est pas indentique. Le code source BASIC est 
	d'abord compilé en bytecode pour être exécuté sur une machine virtuelle à piles. Ce document décris le langage BASIC et son utilisation. 
</p>
<p>
<ul>
<li><a href="#language">Caractéristiques du langage.</a></li>
<li><a href="#reference">référence du langage</a></li>
<li><a href="#index">index des mots réservés et commandes.</a></li>
<li><a href="#examples">examples</a></li>
</ul>
</p>
<h3><a name="language"></a></a>Caractéristques du langage.</h3>
<p>
<ul>
<li>Types de données<br>
  <ul>
	  <li>Entier 32 bits signé, {-2147483648...2147483647}</li>
	  <li>Entier 8 bits (octet) non signé, {0-255}</li>
	  <li>Chaîne de caractères ASCII, {0-127}</li>
	  <li>Nombres en virgules flottante 32 bits</li>
	  <li>Tableau unidimensionnel de ces 4 types de données</li>
  </ul>
</li>
<li>Programmation structurée<br>
  Contrairement au BASIC des années 70-80 <b>vpcBASIC</b> est un language de programmation structuré de type procédural basé sur
  des fonctions déclarées avec le mot réservé <b>FUNC</b> ainsi que des sous-routines déclarées avec
  le mot résservé <b>SUB</b>. Il n'y a pas de numéros de lignes ni de <b>GOTO</b> ou <b>GOSUB</b> comme dans les versions plus ancienne de BASIC.
  Pour l'essentiel je me suis inspiré de <a href="https://fr.wikipedia.org/wiki/QBasic">QBASIC</a> qui venait avec MS-DOS à partir de 1991.<br>
  La compilation se fait en 1 seule passe, cependant les appels en références avant sont possible grâce à l'utilisation du mot clé <b>DECLARE</b>.
  Il en va de même avec les variables tableaux qui doivent-être définies avec la commande <b>DIM</b> avant d'être référencées. Par contre une variable
  scalaire globale est créée automatiquement lors de la première référence si elle n'existe pas. Cette auto-création des variables
  scalaire n'est valide qu'à l'extérieur des fonctions et sous-routines.
</li>

</li>
</ul>	
</p>
<h3><a name="reference">Référence du vpcBASIC</a></h3>
<p>
	vpcBASIC est insensible à casse tous les mots réservés et indentificateurs de variables sont convertis en majuscules par le compilateur.
</p>
<h4>conventions typographiques
</h4>
<p>
	les éléments de syntaxe indiqués entre <b>'['</b> et <b>']'</b> sont des éléments optionnels. si le caractère <b>'+'</b>
	suit le caractère <b>']'</b> l'élément peut-être répété un nombre abritraire de fois.
</p>
<p>le caractère <b>'|'</b> sépare les alternatives</p>
<p>
  Dans les exemples le <b>&gt;</b> au début d'une ligne représente l'invite de la ligne de commande.
</p>

<p>
	<i>expr</i>  signifie une expression arithmétique.<br>
	<i>expr_list</i> liste d'expression numérique. Les éléments sont séparés par la virgule <b>','</b>.<br>
	<i>cond</i>  signifie une condition logique résultant de la comparaison de 2 <i>expr</i>.<br>
	<i>log_expr</i> signifie un ensemble de <i>cond</i> reliées par les opérateurs logiques <b>AND</b> et <b>OR</b>.<br>
	<i>arg_list</i> est la liste des arguments passés à une sous-routine ou fonction. La virgule <b>','</b> est le séparateur de liste.<br>
	<i>val_list</i> est une liste de valeur numérique ou chaîne servant à initialiser un tableau lors de sa déclaration.<br>
	<i>var</i> représente un nom de variable.<br>
	<i>num</i> représente un nombre entier.<br>
	<i>float</i> représente un nombre en virgule flottante<br>
	<i>const</i> représente une constante numérique.<br>
	<i>block</i> groupe d'instructions BASIC.<br>
</p>
<h4>Opérateurs par ordre de précédence</h4>
<p>Cette table montre les opérateurs par ordre de précédence. À précédence égale les opérateurs sont traités de gauche à droite.</p>
<table border="single">
<tr><th>opérateur</th><th>description</th></tr>
<tr><td>()</td><td>Parenthèses de groupement d'expression. Le groupement entre parenthèses est réservé aux expression arithmétiques. 
Les <i>cond</i> et les <i>log_expr</i> ne peuvent pas être regroupées.</td></tr>
<tr><td>func()</td><td>Les fonctions ont la plus haute priorité dans les expression arithmétiques.</td></tr>
<tr><td>* / %</td><td>multiplication, division entière, modulo</td></tr>
<tr><td>+ -</td><td>addition soustraction</td></tr>
<tr><td>= >= < <= <> >< </td><td>les opérateurs de comparaison utilisés dans les <i>cond</i></td></tr>
<tr><td>NOT</td><td> négation logique appliquée au résultat d'une <i>cond</i></td> </tr>
<tr><td>AND</td><td>conjonction logique appliqué entre les <i>cond</i></td> </tr>
<tr><td>OR</td><td>alternative logique appliqué entre les <i>cond</i></td> </tr>
</table>
<h4>nom de variables</h4>
<p>
	Les noms de variables sont insensibles à la casse. Tous les noms sont convertis en majuscules par le compilateur. Un nom peut 
	avoir un maximum de 31 caractères, doit commencer par une lettre mais peut contenir des chiffres et le caractère <b>'_'</b>.
	Le type des variables peut-être déterminé de 2 façon.
	<ol>
	<li>Par utilisation d'un caractère spécial à la fin du nom.
	<ul>
		<li><b>$</b>, il s'agit d'une variable chaîne.</li>
		<li><b>#</b>, il s'agit d'une variable octet.</li>
		<li><b>!</b>, il s'agit d'une variable float32.</li>
		<li>En l'absence d'un caractère spécial la variable est considérée comme entier 32 bits.</li>
	</ul>
	</li>
	<li><b>AS INTEGER|STRING|BYTE|FLOAT</b>
	<div>
	exemple:
	<pre><code>
		dim var1 as integer
		dim var2 as string
		dim var3 as byte, var4 as float
	</code></pre>
	On a donc ici déclarer 4 variables, <b>VAR1</b> de type entier 32 bits. <b>VAR2</b> de type chaîne de caractères. <b>VAR3</b> de type octet et 
	finalement <b>VAR4</b> de type float32.
	</div>
	</li>
	</ol>
	<div>
</p>
<h4>valeurs litérales</h4>
<p>
Les valeurs litérales numérique peuvent-être saisie sous 3 formes:
<ol>
	<li><b>entier en décimal</b>  23, -267 , -32560, 255</li>
	<li><b>entier en hexadécimal</b> $23f2, $fff3</li>
	<li><b>virgule flottante</b> 1.0, 3.23e-23</li>
</ol>
</p>
<p>
Les chaînes de caractères sont saisies entre guillemets <b>'"'</b>. 
Un caractère ASCII est saisie en le précédent de la barre oblique <b>'\'</b>
<div>
<pre><code> example: 
&gt;print "Hello world"
Hello world
&gt;putc \a
a
&gt;|
</code></pre><br>
</div>
</p>
<h4>fonctions et sous-routines</h4>
<p>
	Les paramètres des fonctions et sous-routines sont passées par valeur sauf si le nom de la variable est précédé du 
	caractère <b>'@'</b>. Dans ce cas le paramètre doit-être le nom d'une variable qui est passée par référence.
	<div>
    <pre><code>example:
    sprite(10,10,8,8,@lem#) ' lem# est le nom d'une variable taleau qui contient un sprite.
                            ' ce tableau doit-être passé par référence.</code></pre></div>
</p>
<p>
	Le type de la valeur retournée par une fonctions peut-être déterminé en utilisant un caractère spécial à la fin du nom de la 
	fonction comme pour les variables. Le mot clé <b>AS</b> n'est pas supporté pour les fonctions et non plus pour la liste des arguments de <B>FUNC</B>
	et <b>SUB</b>. Le programmeur doit s'assurer qu'il passe des paramètres du bon type.
</p>
<p>                            
    Si une fonction est appellée comme s'il s'agissait d'une sous-routine, la valeur retournée est simplement jetée comme c'est le cas dans le langage 
    <b>C</b>.
</p>
<h4>commandes BASIC</h4>
<h3><a name="index"></a>index</h3>
<p>
	<ul>
		<li><a href="#ref">@</a></li>
		<li><a href="#abs">ABS</a></li>
		<li><a href="#acos">ACOS</a></li>
		<li><a href="#and">AND</a></li>
		<li><a href="#append">APPEND$</a></li>
		<li><a href="#as">AS</a></li>
		<li><a href="#asc">ASC</a></li>
		<li><a href="#asine">ASINE</a></li>
		<li><a href="#atn">ATN</a></li>
		<li><a href="#beep">BEEP</a></li>
		<li><a href="#box">BOX</a></li>
		<li><a href="#btest">BTEST</a></li>
		<li><a href="#bye">BYE</a></li>
		<li><a href="#case">CASE</a></li>
		<li><a href="#ceil">CEIL</a></li>
		<li><a href="#chr">CHR$</a></li>
		<li><a href="#circle">CIRCLE</a></li>
		<li><a href="#close">CLOSE</a></li>
		<li><a href="#cls">CLS</a></li>
		<li><a href="#con">CON</a></li>
		<li><a href="#const">CONST</a></li>
		<li><a href="#cos">COS</a></li>
		<li><a href="#curcol">CURCOL</a></li>
		<li><a href="#curline">CURLINE</a></li>
		<li><a href="#date">DATE$</a></li>
		<li><a href="#declare">DECLARE</a></li>
		<li><a href="#dim">DIM</a></li>
		<li><a href="#do">DO</a></li>
		<li><a href="#ellipse">ELLIPSE</a></li>
		<li><a href="#else">ELSE</a></li>
		<li><a href="#end">END</a></li>
		<li><a href="#exit">EXIT</a></li>
		<li><a href="#exp">EXP</a></li>
		<li><a href="#fgetc">FGETC</a></li>
		<li><a href="#fill">FILL</a></li>
		<li><a href="#floor">FLOOR</a></li>
		<li><a href="#free">FREE</a></li>
		<li><a href="#for">FOR</a></li>
		<li><a href="#func">FUNC</a></li>
		<li><a href="#hex">HEX$</a></li>
		<li><a href="#input">INPUT</a></li>
		<li><a href="#insert">INSERT$</a></li>
		<li><a href="#insertln">INSERTLN</a></li>
		<li><a href="#instr">INSTR</a></li>
		<li><a href="#invertvid">INVERTVID</a></li>
		<li><a href="#key">KEY</a></li>
		<li><a href="#lcase">LCASE</a></li>
		<li><a href="#left$">LEFT$</a></li>
		<li><a href="#len">LEN</a></li>
		<li><a href="#let">LET</a></li>
		<li><a href="#line">LINE</a></li>
		<li><a href="#loadimg">LOADIMG</a></li>
		<li><a href="#local">LOCAL</a></li>
		<li><a href="#locate">LOCATE</a></li>
		<li><a href="#log">LOG</a></li>
		<li><a href="#log10">LOG10</a></li>
		<li><a href="#loop">LOOP</a></li>
		<li><a href="#max">MAX</a></li>
		<li><a href="#mdiv">MDIV</a></li>
		<li><a href="#mid$">MID$</a></li>
		<li><a href="#min">MIN</a></li>
		<li><a href="#mod">MOD</a></li>
		<li><a href="#next">NEXT</a></li>
		<li><a href="#open">OPEN</a></li>
		<li><a href="#peek">PEEK</a></li>
		<li><a href="#pget">PGET</a></li>
		<li><a href="#play">PLAY</a></li>
		<li><a href="#polygon">POLYGON</a></li>
		<li><a href="#power">POWER</a></li>
		<li><a href="#prepend">PREPEND</a></li>
		<li><a href="#print">PRINT | ?</a></li>
		<li><a href="#pset">PSET</a></li>
		<li><a href="#putc">PUTC</a></li>
		<li><a href="#pxor">PXOR</a></li>
		<li><a href="#randomize">RANDOMIZE</a></li>
		<li><a href="#rect">RECT</a></li>
		<li><a href="#rem">REM | '</a></li>
		<li><a href="#restscr">RESTSCR</a></li>
		<li><a href="#return">RETURN</a></li>
		<li><a href="#right$">RIGHT$</a></li>
		<li><a href="#rnd">RND</a></li>
		<li><a href="#run">RUN</a></li>
		<li><a href="#saveimg">SAVEIMG</a></li>
		<li><a href="#savescr">SAVESCR</a></li>
		<li><a href="#scrldn">SCRLDN</a></li>
		<li><a href="#scrlup">SCRLUP</a></li>
		<li><a href="#seek">SEEK</a></li>
		<li><a href="#select">SELECT</a></li>
		<li><a href="#settmr">SETTMR</a></li>
		<li><a href="#shl">SHL</a></li>
		<li><a href="#shr">SHR</a></li>
		<li><a href="#sine">SINE</a></li>
		<li><a href="#sleep">SLEEP</a></li>
		<li><a href="#sound">SOUND</a></li>
		<li><a href="#sprite">SPRITE</a></li>
		<li><a href="#sqrt">SQRT</a></li>
		<li><a href="#srclear">SRCLEAR</a></li>
		<li><a href="#srload">SRLOAD</a></li>
		<li><a href="#srread">SRREAD</a></li>
		<li><a href="#srsave">SRSAVE</a></li>
		<li><a href="#srwrite">SRWRITE</a></li>
		<li><a href="#str$">STR$</a></li>
		<li><a href="#sub">SUB</a></li>
		<li><a href="#subst$">SUBST$</a></li>
		<li><a href="#tan">TAN</a></li>
		<li><a href="#then">THEN</a></li>
		<li><a href="#ticks">TICKS</a></li>
		<li><a href="#time$">TIME$</a></li>
		<li><a href="#timeout">TIMEOUT</a></li>
		<li><a href="#tkey">TKEY</a></li>
		<li><a href="#trace">TRACE</a></li>
		<li><a href="#tune">TUNE</a></li>
		<li><a href="#ubound">UBOUND</a></li>
		<li><a href="#ucase">UCASE</a></li>
		<li><a href="#until">UNTIL</a></li>
		<li><a href="#use">USE</a></li>
		<li><a href="#val">VAL</a></li>
		<li><a href="#vgacls">VGACLS</a></li>
		<li><a href="#wend">WEND</a></li>
		<li><a href="#while">WHILE</a></li>
	</ul>
	<div class="item_div"></div>
</p>
<p>
	
	<ul>
	<li><a name="ref"></a><b>@</b><br>
	Permet de passer une variable par référence.<br>
	Lors de l'appel d'une sous-routine ou d'une fonction normalement les arguments sont passé par valeur. 
	<div>Mais certaines procédures ou fonctions utilisent des arguments de type pointeur. 
	Il suffit de faire précéder le nom de la variable du caractère <b>@</b> pour passer une pointeur vers
	cette variable.</div>
	<div>exemple:
	<pre><code>
	&gt;sprite(x,y,w,h,@sp)
	</code></pre>
	Pour afficher un sprite sur l'écran VGA il faut passer le tableau qui contient le sprite par référence. Dans cet exemple sp est une tableau de type
	octets qui contient le sprite à afficher.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="abs"></a><b>ABS(expr)</b><br>
	Fonction qui retourne la valeur absolue de l'expresssion passée comme paramètre.
	<pre><code>example:
	&gt;b=-5
	&gt;? abs(3*b)
	15
	&gt;_
	</code></pre>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="acos"></a><b>ACOS(expr)</b><br>
	Fonction qui retourne l'arc-cosinus de l'expression passée comme paramètre.
	<pre><code>
	&gt;? acos(.5)
	1.0472
	&gt;_
	</code></pre>
	La valeur retournée est en radians.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="and"></a><b>AND</b><br>
	Conjonction logique <b>ET</b> utilisé dans les <i>log_expr</i>.
	<div>exemple:
	<pre><code>
	if hour>=12 and hour<=17 then print "afternoon" end if
	REM si la varialbe <i>hour</i> a une valeur entre 12 et 17 imprime le mot <i>afternoon</i>.
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="append"></a><b>APPEND$(str_expr1, str_expr2)</b><br>
	Fonction chaîne qui retourne la concaténation de str_expr2 à la fin de str_expr1.
	<div>exemple:
	<pre><code>
		&gt;? append$("hello ","world!")
		hello world!
		&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="as"></a><b>AS type_donne</b><br> 
	Mot réservé pour spécififier le type de donné
	d'une variable dans une déclaration. Voir <a href="#dim">DIM</a>.
	<div>exemple:
	<pre><code>
		&gt;dim message as string
	</code></pre>
	Dans cet exemple message est une variable de type chaîne.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="asc"></a><b>ASC(str_expr)</b><br>
	Fonction qui retourne la valeur ASCII du premier caractère de la chaîne str_expr.
	<div>exemple:
	<pre><code>
	&gt;? asc("bonjour")
	98
	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="asine"></a><b>ASINE(expr)</b><br>
	Fonction qui retourne l'arc-sinus de expr.
	<div>
	exemple:
	<pre><code>
		&gt;? asine(0.5)
		0.523599
		&gt;_
	</code></pre></div>
	La valeur retournée est en radians.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="atn"></a><b>ATN(expr)</b><br>
	Fonction qui retourne l'arctangeante de expr.
	<div>exemple:
	<pre><code>
		&gt;? atn(1.0)
		0.785398
		&gt;_
	</code></pre></div>
	La valeur retournée est en radians.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="beep"></a><b>BEEP()</b><br> Génère une tonalité de 1000 hertz d'une durée de 40 millisecondes.
	<div>
	<pre><code>example:
	&gt;BEEP
	
	&gt;_
	</code></pre>
	</div>
	Pour les commandes qui n'utilisent aucun argument les parenthèses sont facultatives.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="box"></a><b>BOX(x0,y0,width,height)</b><br> Dessine un rectangle plein sur le moniteur VGA. 
	<ul><li><b>x0</b>, représente la coordonnée x en pixels du coin supérieur gauche.</li>
	<li><b>y0</b>, représente la coordonnée y en pixels du coin supérieur gauche.</li>
	<li><b>width</b> représente la largeur de la boite en pixels.</li>
	<li><b>height</b> représente la hauteur de la boite en pixels.</li>
	</ul>
	<div>
	<pre><code>example:
	&gt;BOX(10,20,100,50)
	
	&gt;_
	</code></pre>
	<div>
	<canvas id="BoxCanvas" width="480" height="240" sytle="background-color:black;">
	Votre fureteur ne supporte pas les canvas HTML5.</canvas>
	<script>
	var c = document.getElementById("BoxCanvas");
	var ctx = c.getContext("2d");
	ctx.fillStyle="#000000";
	ctx.fillRect(0,0,480,240);
	ctx.fillStyle="#ffffff";
	ctx.fillRect(10, 20, 100, 50);
	</script></div> 
	Dans cet exemple, le coin supérieur gauche du rectangle est à la position {10,20}, la largeur est de 100 pixels et la hauteur
	de 50 pixels. Le fonctions graphiques sont limitées au moniteur VGA même si la commande est faite à partir de la console <B>REMOTE</B>.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="btest"></a><b>BTEST(<i>expr</i>,bit)</b><br>
	Fonction qui vérifie l'état d'un bit. Retourne <i>vrai</i> si le bit est à 1 sinon retourne <i>faux</i>.
	<ul>
	<li><b>expr</b> valeur entière pour laquelle on veut vérifier l'état d'un bit.</li>
	<li><b>bit</b> bit est une expression de valeur comprise entre 0 et 31 puisque les entiers sont de 32 bits. <b>0</b> est le bit 
	le plus faible et <b>31</b> le plus fort.</li>
	</ul>
	<div>exemple:
	<pre><code>
	&gt;n=44
	&gt;if btest(n,0) then ? "nombre impair" else ? "nombre pair" end if               
	nombre pair                                                                     
																					
	&gt;n=65                                                                           
																					
	&gt;if btest(n,0) then ? "nombre impair" else ? "nombre pair" end if               
	nombre impair                                                                   
																					
	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="bye"></a><b>BYE</b><br>
	Cette commande termine l'éxécution d'un programme et peut-être utilisée n'importe où à l'intérieur d'un programme.
	Invoquée en mode interactif provoque la sortie vers le shell de commandes.
	<div>exemple:
	<pre><code>
	&gt; REM imprime chaque caractere saisie au clavier jusqu'a ce que 'q' soit enfoncé.
	&gt;while 1                    

	&gt;k=tkey()

	&gt;&gt;if k=\q then bye end if

	&gt;&gt;putc k

	&gt;&gt;wend
	ffafafajlfkjafklaj
	&gt;_
	
	&gt;bye
	$echo a provoquer un retour au shell de commandes.
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="case"></a><b>CASE</b><br>
	Voir <a href="#selectcase">SELECT CASE</a>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="ceil"></a><b>CEIL(expr)</b><br>
	Fonction qui retourne l'entier arrondie au plus grand d'un nombre.
	<div>exemple:
	<pre><code>
	&gt;? ceil(3.0001)
	4 

	&gt;? ceil(-3.0001)
	-3 

	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="chr"></a><b>CHR$(n)</b><br>
	Fonction qui retourne une chaîne de caractère de longueur 1 correspondant au code ASCII de n.
	<div>exemple:
	<pre><code>
	&gt;? chr$(65)
	A 

	&gt;? chr$(97)
	a 

	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="circle"></a><b>CIRCLE(cx,cy,r)</b><br>
	Fonction graphique qui dessine un cercle sur le moniteur VGA.
	<ul>
	<li><b>cx</b>, coordonnée x du centre du cercle exprimé en pixels.</li>
	<li><b>cy</b>, coordonnée y du centre du cercle exprimé en pixels.</li>
	<li><b>r</b>, rayon du cercle exprimé en pixels.</li>
	</ul>
	<div>exemple:
	<pre><code>
	&gt;for i=10 to 100 step 10: circle(240,120,i):next i

	&gt;_
	</code></pre>
	<div>
	<canvas id="CircleCanvas" width="480" height="240">
	Votre fureteur ne supporte pas les canvas HTML5.
	</canvas>
	<script>
	var c = document.getElementById("CircleCanvas");
	var ctx = c.getContext("2d");
	ctx.fillStyle="#000000";
	ctx.fillRect(0,0,480,240);
	ctx.strokeStyle="#ffffff";
	for (i=10;i<110;i+=10){
		ctx.beginPath();
		ctx.arc(240,120,i,0,2*Math.PI);
		ctx.stroke();
	}
	</script> 
	</div>
	Cette exemple dessine 9 cercles concentriques au centre de l'écran.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="close"></a><b>CLOSE(#n)</b><br>
	Ferme un fichier préalablement ouvert avec la commande <a href="#open">OPEN</a>. <b>n</b> est le numéro assigné au fichier
	lors de son ouverture.
	<div>exemple de programme utilisant un fichier.
	<pre><code>
	rem file system test
	open "hello.txt" for output as #1
	print #1,"hello world\r"
	putc #1, 33  : putc #1, 10
	v$="bonjour\r": n=3*5
	? #1, v$, n, 4*5+20, 32.5e-3
	close(#1)
	dim hello$
	open "hello.txt" for input as #1
	input #1, hello$
	c=fgetc(#1)
	input #1,x$,n1,n2,n3!
	close(#1)
	? hello$,c,x$,n1,n2,n3!
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="cls"></a><b>CLS</b><br>
	Efface l'écran et positionne le curseur texte dans le coin supérieur gauche.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="con"></a><b>CON REMOTE|LOCAL</b><br>
	Cette commande fonctionne à l'identique de la même commande dans le shell de commande et permet de passer de la console
	locale à la console à distance. Cependant le passage d'un console à l'autre en vpcBASIC n'affiche aucun message et n'efface
	pas l'écran.
	<div>exemple:
	<pre><code>
	&gt;REM impression d'un message sur la console remote 
	&gt;REM a partir de la console locale.
	&gt;con remote: ? "hello world!" : con local
	&gt;_
	</code></pre>
	Dans cet exemple on transfert à la console <B>REMOTE</B> ensuite on imprime le message <b>"hello world!"</b> pour ensuite
	revenir à la console <B>LOCAL</B>. Cette commande peut-être utilisée pour envoyer et recevoir de l'information via le port 
	<B>COM</B> à partir d'un programme BASIC.
	</div> 
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="const"></a><b>CONST nom=valeur [,nom=valeur]</b><br> Déclare une ou plusieurs constantes séparées par une virgule <b>','</b>.
	<ul><li><b>nom</b> est le nom de la constante. Le type de la constante est défini de la même manière que pour les variables.</li>
	<li><b>valeur</b> selon le type de la constante il s'agit d'un entier, d'un float ou d'une chaîne ASCII.</li></ul>
	<div>exemple:
	<pre><code>
	&gt;const pi as float=3.1415, e as float=2.718, nom$="Capitaine Bonhomme"

	&gt;? pi,e,nom$
	3.1415 2.718 Capitaine Bonhomme 

	&gt;nom$="hello"

	line: 5
	token#: 1
	Constant can't be redefined
	tok_id: 3
	tok_value: 
	token_string: NOM$

	&gt;_
	</code></pre>
	Lorsqu'on tente de redéfinir une constante le compilateur affiche une erreur.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="cos"></a><b>COS(expr)</b><br>
	Fonction trigonométrique cosinus. <i>expr</i> est exprimé en radians.
	<div>exemple:
	<pre><code>
	&gt;? cos(3.1415) ' cosinus de PI i.e. 180&deg;
	-1 

	&gt;? cos(3.1415/4) ' cosinus de 45&deg;
	0.707123 

	>
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="curcol"></a><b>CURCOL()</b><br>Retourne la poisition colonne du curseur texte, {0..79}.
	<div>exemple:
	<pre><code>
	if curcol()=78 then locate(curline()+1,0) end if
	</code></pre>
	Dans cet exemple on force un retour au début de la ligne suivante lorsque le curseur texte atteint la colonne 78.
    </div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="curline"></a><b>CURLINE()</b><br>Retourne la position ligne du curseur texte, {0..29}.
	<div>exemple:
	<pre><code>
	if curline()=29 and curcol()=79 then scrlup(): locate(curline(),0) end if
	</code></pre>
	</div>
	Dans cet exemple on force un défilement vers le haut de l'écran lorsque le curseur atteint la dernière position de l'écran.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="date"></a><b>DATE$</b><br>
	Fonction chaîne qui retourne la date.
	<div>exemple:
	<pre><code>
	&gt;? date$
	Thursday 2018/06/28  

	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="declare"></a><b>DECLARE FUNC|SUB nom(arg_list)</b><br>Ce mot réservé sert à déclarer une fonction ou sous-routine sans la définir.
	Ça permet de faire des appels à celle-ci avant qu'elle ne soit définie dans le texte source. Ce qui authorise les appels circulaire.
	<div>exemple:
	<pre><code>
	&gt;declare sub test1(n)

	&gt;sub test2(n)

	&gt;&gt;test1(2*n)

	&gt;&gt;end sub

	&gt;sub test1(n)

	&gt;&gt;? 1.0*n/3

	&gt;&gt;end sub

	&gt;test2(45)
	30 

	&gt;test2(4)
	2.66667 

	&gt;_
	</code></pre>
	Dans cet exemple la sous-routine <b>test1</b> est définie après la sous-routine <b>test2</b> cependant <b>test2</b> peut appeller <b>test1</b> car
	elle a été prédéclarée. Si on supprimait la déclaration le compilateur afficherait une erreur lorsque <b>test2</b> appelle <b>test1</b>.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="dim"></a><b>DIM</b><br>Mot réservé pour la déclaration des variables. Il y a plusieurs formes.
	<ul>
	<li><b>DIM var_name[$|#|!] [,var_name[$|#|!]]</b> pour déclarer des variables sans les initialiser. Le type de variable
	est déterminé par le dernier caractère du nom de la variable.</li>
	<li><b>DIM var_name as DATATYPE [,var_name as DATATYPE]</b>, pour déclarer des variables en spécifiant le type de donnée par
	utilisation du mot réservé <b>AS</b> suivit d'un des spécificateur de type suivant: <b>BYTE,INTEGER,FLOAT,STRING</b>.</li>
	<li><b>DIM table(10) as INTEGER=(1,2,3,4,5,6,7,8,9.10)</b>, pour déclarer un tableau à 1 dimension et l'initialiser.</li>
	</ul>
	<div>Chaque déclaration de variable peut-être suivie d'un caractère <b>=</b> et d'une valeur d'initialisation.</div>
	 <div>exemple:
	 <pre><code>
		&gt;dim table(10)=(1,2,3,4,5,6,7,8,9,10)

		&gt;? table(5)
		5  

		&gt;dim message(3) as string=("hello","hi","bonjour")

		&gt;? message(2)
		hi 

		&gt;dim a#=245                                                                     
																						
		&gt;? a#                                                                           
		245                                                                             
																						
		&gt;_
	 </code></pre>
	 </div>
	<div><a href="#index">index</a></div>
	 </li>
	<div class="item_div"></div>
	 <li><a name="do"></a><b>DO</b><br>
	  <i>block</i><br>
	  <b>LOOP WHILE <i>log_expr</i></b><br>
	  Le bloc d'instruction est exécuté en boucle tant que <i>log_expr</i> est vrai.<br>
	  <b>DO</b><br>
	  <i>block</i><br>
	  <b>LOOP UNTIL <i>log_expr</i></b></b><br> 
	  Le bloc d'instruction est exécuté en boucle jusqu'à ce que <i>log_expr</i> soit vrai.
	<pre><code>example:
	&gt;i=0 : DO ? i : i=i+1 LOOP UNTIL i=5
	0
	1
	2
	3
	4
	&gt;i=9 : DO ? i : i=i-1 : LOOP WHILE i
	9
	8
	7
	6
	5
	4
	3
	2
	1
	</code></pre>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="ellipse"></a><b>ELLIPSE(x0,y1,x1,y1)</b><br>
	Dessine une ellipse circonscrite dans un rectangle. Les coordonnées sont en pixels.
	<ul>
		<li><b>{x0,y0}</b> coordonnées d'un des coin du rectangle.</li>
		<li><b>{x1,y1}</b> coordonnées du coin opposé en diagonale du rectangle.</li>
	</ul>
	<div>exemple:
	<pre><code>
	&gt;ellipse(200,100,280,140)

	&gt;_
	</code></pre>
	</div>
	<div>
	<canvas id="EllipseCanvas" width="480" height="240">Votre fureteur ne supporte pas les canvas HTML5.</canvas>
	<script>
	var c = document.getElementById("EllipseCanvas");
	var ctx = c.getContext("2d");
	ctx.fillStyle="#000000";
	ctx.fillRect(0,0,480,240);
	ctx.strokeStyle="#ffffff";
	ctx.beginPath();
	ctx.ellipse(240, 120, 80,40, 0, 0, 2 * Math.PI);
	ctx.stroke(); 	
	</script> 
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="else"></a><b>ELSE</b><br>
	Est utilisé avec le <a href="#if">IF</a> et le <a href="#selectcase">SELECT CASE</a>.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="end"></a><b>END FUNC</b><br>
	Termine la définiction d'une fonction. Voir <a href="#function">FUNC</a>.<br>
	<div class="item_div"></div>
	<b> END SUB</b><br>
	Termine la définiction d'une sous-routine. Voir <a href="#sub">SUB</a>.<br>
	<div class="item_div"></div>
	<b>END IF</b><br>
	Termine une structure de contrôle <b>IF ... THEN ... ELSE ... END IF</b>. Voir <a href="#if">IF</a><br>
	<div class="item_div"></div>
	<b>END SELECT</b><br>
	Termine une structure de contrôle <b>SELECT CASE</b>. Voir <a href="#selectcase">SELECT CASE</a>.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="exit"></a><b>EXIT SUB</b><br>
	Permet la sortie prématurée d'une sous-routine. Voir <a href="#sub">SUB</a>.
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="exp"></a><b>EXP(expr)</b><br>
	Fonction qui retourne un float de valeur e^expr, ou <b>e</b> est la base naturelle.
	<div>exemple:
	<pre><code>
	&gt;? exp(4)
	54.5981 

	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="fgetc"></a><b>FGETC(#n)</b><br>
	Cette fonction retourne un caractère lu à partir d'un fichier.
	<ul>
	<li><b>#n</b>, est le numéro qui a été assigné au fichier lors de son ouverture. Voir <a href="#open">OPEN</a>.</li>
	</ul>
	<div>exemple:
	<pre><code>
	&gt;open "snake.bas" for input as #1: ? chr$(fgetc(#1)):close(#1)
	r 

	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>	
	<div class="item_div"></div>
	<li><a name="fill"></a><b>FILL(x,y)</b><br>
	Procédure graphique qui remplie une figure géométrique fermée.
	<div>exemple:
	<pre><code>
	</code></pre>
	<b>AVERTISSEMENT:</b> Il s'agit d'une procédure récursive qui fait déborder la pile lorsque la figure dépasse une certaine taille.
	Il se peut donc que l'ordinateur génère une exception lorsqu'elle est utilisée.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="floor"></a><b>FLOOR(expr)</b><br>
	Fonction de type entier qui accepte une expression arithmétique qui résulte en un type float pour retourner la partie entière de 
	cette expression.
	<div>exemple:
	<pre><code>
	&gt;? floor(45.23)
	45 

	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="for"></a><b>FOR <i>var=expr</i> TO <i>expr</i> [STEP <i>expr</i>]</b><br>
	  <i>block</i><br>
	<b>NEXT <i>var</i></b><br>
	Permet l'exécution d'un bloc d'instructions en boucle un nombre de fois déterminé par l'incrémentation d'une variable. Le programme sort de
	la boucle lorsque la variable dépasse la valeur de la limite. l'incrément par défaut est <b>1</b>. Si <b>STEP</b> est présent l'incrément est
	le résultat d'<i>expression</i> et peut-être un entier quelconque. La valeur de la variable de contrôle est vérifiée au début de la boucle
	d'instructions. Si au départ elle dépasse la limite le bloc d'instruction n'est jamais exécuté.<br>
	<div>exemple:
	</div>
	<pre><code>
	&gt;for i=0 to 10 step 2

	&gt;&gt;? i

	&gt;&gt;next i
	0  
	2  
	4  
	6  
	8  
	10  

	&gt;_
	</code></pre>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><b><a name="func"></a>FUNC name(<i>arg_list</i>)</b><br>
	[<b>LOCAL var_list</b>]<br>
	<i>block</i><br>
	<b>RETURN <i>expr</i></b><br>
	<b>END FUNC</b><br>
	Sert à définir une fonction.<br>
	<ul>
		<li><b>name</b> est le nom de la fonction qui sera utilisé pour son appel.</li>
		<li><i>arg_list</i> Liste du nom des arguments de la fonctions. Les éléments sont séparé par la virgule <b>','</b></li>
		<li><b>LOCAL var_list</b> Si la fonction utilise des variables locales la liste doit-être donnée au début.</li>
		<li><i>block</i> bloc d'instructions exécuté par cette fonction.</li>
		<li><b>RETURN <i>expr</i></b> Cette directive termine la fonction en retournant la valeur de l'expresssion qui suit. Cette 
		directive peut apparaître plusieurs fois dans le bloc d'instruction dans une structure conditionnelle.
		<pre><code>example:
		REM cette fonction calcule  la factorielle d'un entier
		REM méthode récursive
		FUNC fact(n)
		  if n<1 then 1/0 end if ' nombre &lt; 1 génère une exception
		  if n=1 then return 1 end if
		  return n*fact(n-1)
		END FUNC
		
		REM même fonction mais en utilisant une boucle FOR
		FUNC fact(n)
		LOCAL f,i
		   f=1
		   for i=2 to n 
		     f=f*i
		   next i
		   return f
		END FUNC
		</code></pre></li>
	</ul>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="hex"></a><b>HEX$(expr)</b><br>
	Fonction chaîne qui retourne la représentation hexadécimale d'un entier.
	<ul>
		<li><b>expr</b>, est évaluée et sa valeur convertie en chaîne hexadécimale. Si cette valeur est un float la partie décimale
		est tronquée.</li>
	</ul>
	<div>exemple:
	<pre><code>
	&gt;? hex$(3.1415)
	$3 

	&gt;? hex$(3.9)
	$3 

	&gt;? hex$(25.2 * 3.5)
	$58 

	&gt;_
	</code></pre>
	Les chaînes représentant un nombre en hexadécimal débute par le caractère <b>$</b> pour éviter toute confusion avec la représentation
	décimale.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="if"></a><b>IF <i>log_expr</i> THEN</b><br>
	<i>block</i><br>
	[<b>ELSE</b><br>
	<i>block</i>]<br>
	<b>END IF</b><br>
	Structure de contrôle qui évalue l'expression logique qui suit le <b>IF</b> et si la valeur est vrai le bloc d'instruction qui
	suit le <b>THEN</b> est exécuté. Dans le cas contraire c'est le bloc d'instruction qui suit le <b>ELSE</b>
	qui est exécuté. La clause <b>ELSE</b> est optionnelle.
	<div>exemple:
	<pre><code>
	IF btest(4,0) then
	  ? "nombre impair"
	ELSE
	  ? "nombre pair"
	END IF
	REM va imprimé <i>nombre pair</i>
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="input"></a><b>INPUT [#n,] | [<i>invite</i>,] <i>var_list</i></b>
	<ul>
		<li><b>#n</b>, est le numéro d'un fichier ouvert si la lecture doit se faire à partir d'un fichier.</li>
		<li><b>invite</b> est un message facultatif à imprimer à l'écran avant la saisie des données.</li>
		<li><b>var_list</b> est la liste des variables auquelles les valeurs saisies au clavier seront affectées.
		La saisie se fait une variable à la fois dans leur ordre d'apparation dans la liste. Pour chaque variable
		son nom est affichée à l'écran suivit d'un point d'interrogation.</li>
	</ul>
	<div>exemple:
	<pre><code>
 	 &gt;INPUT "Entrez votre prenom et votre age", nom$, age
	 Entrez votre prenom et votre age
	 prenom? <i>Arthur</i>
	 age? <i>40</i>
	 
	 &gt;? nom$, age
	 Arthur 40
	 
	 &gt;_
	</code></pre>
	<b>#n</b> et <b>invite</b> sont mutuellement exclusifs. <b>#n</b> n'est utilisé que pour la lecture de fichier et <b>invite</b> pour
	la saisie à l'écran.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><a name="insert"></a><b>INSERT$(s1,s2,expr)</b><br>
	Fonction chaîne qui sert à insérer un chaîne dans une autre.
	<ul>
		<li><b>s1</b>, est une expression de type chaîne.</li>
		<li><b>s2</b>, est une expression de type chaîne qui sera insérée dans <b>s1</b>.</li>
		<li><b>expr</b>, l'évaluation de cette expression doit résulter en un entier qui représente la position d'insertion de <b>s2</b>
		dans <b>s1</b>. Le premier caractère d'une chaîne porte l'indice 1.</li>
	</ul>
	</li>
	<div>exemple:
	<pre><code>
	&gt;heo$="heo"

	&gt;ll$="ll"      

	&gt;? insert$(heo$,ll$,3)
	hello 

	&gt;_
	</code></pre>
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
	<li><b>KEY()</b><br>
	Cette fonction retourne la touche tapée au clavier ou <b>0</b> si aucune touche n'est tapée.
	<pre><code>example:
	CASE SELECT key()
	case \q 'quitte le programme
	  bye
	case \e ' efface l'écran
	  cls
	case \h ' salutation
	  print "hello\n" ' \n à l'intérieur d'une chaîne pour imposer un retour à la ligne.
	end SELECT
	REM j'ai mélanger intentionnellement les mots réservés entre majuscules et minuscules
	REM pour montrer que la casse n'a pas d'importance.
	</code></pre></li>
	<li><b>LEN(<i>var$</i>)</b><br>
	<b>LEN ("chaîne")</b><br> 
	Cette fonction retourne la longueur de la chaîne ASCII.
	<pre><code>example:
	&gt;nom$="Arthur Roy"
	&gt;? len(nom$)
	10
	&gt;? len("hello world")
	11
	&gt;|</code></pre>
	</li>
    <li><b>[LET] <i>var_name[#]</i>i>[(<i>epxr</i>)]=<i>expr</i></b><br>
    <b>[LET] <i>var_name$</i>[(<i>expr</i>)]=<i>chaîne</i></b><br>
    Assigne une valeur à une variable. Le mot réservé <b>LET</b> est entre crochets car il est optionnel.
    <pre><code>example:
    LET a=34*5
    a=34*5  REM c'est la même chose
    REM ça peut aussi être une variable tableau
    DIM tab(4)
    tab(1)=-1234  ' le premier élément du tableau vaut maintenenat <b>-1234</b>
    </code></pre>
    </li>
    <li><b>LINE(x0,y0,x1,y1,color)</b><br>
    Dessine une ligne à l'écran.
    <ul>
    <li><b>{x0,y0}</b> coordonnées première extrémité de la ligne.</li>
    <li><b>{x1,y1}</b> coordonnées de l'autre extrémité de la ligne.</li>
    <li><b>color</b> couleur (ton de gris) de la ligne.</li>
    </ul>
    <pre><code>example:
    line(0,0,100,100,15)</code></pre>
    </li>
	<li><b>LOCAL <i>var_list</i></b><br>
	Déclaration de la liste des variables utilisées dans une 
	<a href="#function">fonction</a> ou une <a href="#sub">sous-routine.</a></li>
	<li><b>LOCATE(ligne,colonne)</b><br>
	Positionne le curseur texte à l'endroit désigné.
	<ul>
		<li><i>ligne</i> numéro de la ligne, {0-20}</li>
		<li><i>colonne</i> numéro de la colonne, {0-39}</li>
	</ul>
	<pre><code>example:
	LOCATE(10,0) ' le curseur texte est maintenant au début de la 11ième ligne.
	</code></pre>
	</li>
	<li><b>LOOP</b><br>
	voir <a href="#do">DO</a></li>
	<li><b>MAX(<i>expr1</i>,<i>expr2</i>)</b><br>
	Cette fonction retourne le plus grand des 2 entiers.
	<pre><code>example:
	&gt;? max(56,30)
	56
	&gt;|</code></pre></li>
	<li><b>MDIV(<i>expr1</i>,<i>expr2</i>,<i>expr3</i>)</b><br>
	Cette fonction retourne <i>expr1*expr2/expr3</i>. Le résultat de la 
	multiplication est conservé sur 32 bits pour obtenir une valeur juste pour la division.
	<pre><code>
	&gt; ? 32540*8/33
	-54 <i>'mauvaise réponse à cause du débordement de la multiplication.</i>	
	&gt;? mdiv(3540,8,33)
	7888 <i>'bonne réponse car le résultat de la multiplication est conservé sur 32 bits.</i>
	&gt;REM multiplication d'un nombre par une approximation rationnelle de PI
	&gt;? mdiv(5400,355,113)
	16964 <i>'erreur &lt; 0,5 </i>
	</code></pre></li>
	<li><b>MIN(<i>expr1</i>,<i>expr2</i>)</b><br>
	Cette fonction retourne le plus petit des 2 entiers.
	<pre><code>example:
	&gt;? min(34,-5)
	-5
	&gt;|</code></pre></li>
	<li><b>NEXT <i>var_name</i></b><br>
	Voir <a href="#for">FOR</a></li>
	<li><b>NOISE(<i>expr</i>)</b><br>
	Produit un bruit blanc pour une durée <i>expr</i> exprimée en millisecondes.
	<pre><code>example:
	&gt;noise(100) 'produit le bruit d'une chute d'eau durant 0,1 seconde.
	</code></pre></li>
	<li><b>NOT <i>log_expr</i></b><br>
	Négation de la valeur d'une expression logique.
	<pre><code>example:
	if not 3&gt;4 then ? "3 n'est pas plus grand que 4" end if
	3 n'est pas plus grand que 4
	</code></pre></li>
    <li><b><i>log_expr1</i> OR <i>log_expr2</i></b><br>
    retourne vrai si l'une ou l'autre des 2 <i>log_expr</i> est vrai.
    <pre><code>example:
    while 1
    if key() or jstick()=1 then bye end if
    wend
    REM sort de la boucle si une touche ou le bouton du joystik
    REM est enfoncé.
    </code></pre></li>
	<div class="item_div"></div>
	<li><a name="pget"></a><b>PGET(x,y)</b><br>
	Retourne l'état du pixel à la position {x,y}. 
	<ul>
		<li><b>{x,y}</b>, sont les coordonnées du pixel dont on veut obtenir l'état.</li>
	</ul>
	<div>exemple:
	<pre><code>
	&gt;vgacls ' efface l'ecran VGA

	&gt;box(200,100,80,40) ' dessine une boite au centre

	&gt;?pget(199,99)
	0  

	&gt;?pget(240,120)
	1  

	&gt;_
	</code></pre>
	On dessine une boite ensuite on vérifie l'état du pixel juste en dehors de la boite dans son coin supérieur gauche. Ensuite l'état du
	pixel au centre de la boite.
	</div>
	<div><a href="#index">index</a></div>
	</li>
	<div class="item_div"></div>
    <li><b>PRINT|? [<i>expr</i>|<i>chaîne</i>|<i>var</i>] [,<i>expr</i>|<i>chaîne</i>|<i>var</i>]+ [;]</b><br>
    Imprime à l'écran la liste des expressions, chaîne ou variable. Un espace sépare chaque valeur. Si la commande est terminée
    par une <b>';'</b> il n'y a pas de retour à la ligne.
    <pre><code>example:
    &gt;DIM a=34, msg$="hello world"
    &gt;print a, msg$, "bonjour" 
    34 hello world bonjour
    
    &gt;|
    </code></pre></li>
	<div class="item_div"></div>
    <li><a name="pset"></a><b>PSET(x,y,c)</b><br>
    Procédure graphique définir la couleur d'un pixel sur l'écran VGA.
    <ul>
		<li><b>{x,y}</b>, sont les coordonnées du pixel à modifier.</li>
		<li><b>c</b>, est la nouvelle couleur du pixel. <b>c</b>est dans l'intervalle {0..15}. Puisqu'il s'agit d'un affichage
		monochrome les valeurs {0..7} représente un pixel noir et les valeurs {8..15} un pixel blanc.</li>
    </ul>
    <div>exemple:
    <pre><code>
		&gt;pset(240,120,7) ' le pixel sera noir.
		
		&gt;pset(240,120,12) ' le pixel sera blanc.
    </code></pre>
    </div>
	<div><a href="#index">index</a></div>
    </li>
	<div class="item_div"></div>
    <li><b>PUTC expr</b><br>
    Imprime un caractère à l'écran sans ajout d'espace ou de retour à la ligne. Si <i>expr</i> est évaluée en dehors
    de l'intervalle {0-127} rien n'est imprimé. La majorité des codes entre 0 et 31 n'ont aucun effet. les codes reconnus sont les suivants:
    <ul>
		<li><b>7</b> alerte sonore</li>
		<li><b>9</b> tabulation</li>
		<li><b>10</b> retour à la ligne</li>
		<li><b>12</b> efface écran</li>
		<li><b>13</b> retour à la ligne</li>
    </ul>
    <pre><code>example:
    &gt;putc \a : putc 98
    ab
    &gt;
    </code></pre></li>
	<div class="item_div"></div>
    <li><a name="pxor"></a><b>PXOR(x,y)</b><br>
    Procédure graphique pour inverser l'état d'un pixel.
    <ul>
		<li><b>{x,y}</b>, sont les coordonnées du pixel dont l'état doit-être inversé.</li>
    </ul>
		<div>exemple:
		<pre><code>
			&gt;while not tkey():pxor(240,120):sleep(500);wend
			
			&gt;_
		</code></pre>
		Cet exemple fait clignter le pixel au centre de l'écran avec une période d'une seconde.
		</div>
	<div><a href="#index">index</a></div>
    </li>
	<div class="item_div"></div>
    <li><b>RECT(x,y,width,height,color)</b><br>
    Dessine un rectangle vide à l'écran.
    <ul>
    <li><b>{x,y}</b> coordonnée du coin supérieur gauche</li>
    <li><b>width</b> largeur du  rectangle en pixels.</li>
    <li><b>height</b> auteur du rectangle en pixels.</li>
    <li><b>color</b> couleur (ton de gris) du périmèter du rectangle.</li>
    </ul>
    <pre><code>RECT(10,10,20,60,7) ' position {10,10}, largeur 20, hauteur 60,  couleur 7</code></pre></li>
	<li><b>REM|' <i>texte</i></b><br>
	Indique un commentaire. Les commentaires se termine à la fin de la ligne.
	<pre><code>example:
	REM ce commentaire se termine a la fin de ligne.
	' l'apostrophe peut remplacé le mot REM.</code></pre></li>
	<li><b>RETURN</b><br>
	Voir <a href="#function">FUNC</a></li>
	<li><b>RND()</b><br>
	Cette fonction retourne un entier de 16 bits pseudo aléatoire.
	<pre><code>example:
	&gt;while not key() : ? rnd() : wend
	REM imprime sans arrêt une série de nombre aléatoire.
	REM il faut enfoncer une touche du clavier pour arrêter l'exécution.</code></pre></li>
	<li><b>SCRLUP(expr)</b><br>
	Fait glisser l'affichage vers le haut d'un nombre de pixels correspondant à la valeur
	de <i>expr</i>
	<pre><code>example:
	&gt; scrlup(8) ' défilement vers le haut de la hauteur d'un caractère.</code></pre></li>
	<li><b>SCRLDN(expr)</b><br>
	Fait glisser l'affichage vers le bas d'un nombre de pixels correspondant à la valeur
	de <i>expr</i>
	<pre><code>example:
	&gt; scrldn(8) ' défilement vers le bas de la hauteur d'un caractère.</code></pre></li>
	<li><b>SCRLRT(expr)</b><br>
	Fait glisser l'affichage vers la droite d'un nombre de pixels correspondant à la valeur
	de <i>expr</i>. Cette valeur doit-être un nombre pair, sinon le nombre pair inférieur est choisi.
	<pre><code>example:
	&gt; scrlrt(6) ' défilement vers la droite de la largeur d'un caractère.</code></pre></li>
	<li><b>SCRLLT(expr)</b><br>
	Fait glisser l'affichage vers la gauche d'un nombre de pixels correspondant à la valeur
	de <i>expr</i>. Cette valeur doit-être un nombre pair, sinon le nombre pair inférieur est choisi.
	<pre><code>example:
	&gt; scrllt(6) ' défilement vers la gauche de la largeur d'un caractère.</code></pre></li>
	<li><a name="selectcase"></a><b>SELECT CASE expr</b><br>
	<b>CASE </b><i>expr_list</i><br>
	<i>block</i><br>
	[<B>case </B><i>expr_list</i><br>
	<i>block</i>]+<br>
	[<b>CASE ELSE</b><br>
	<i>block</i>]<br>
	<b>END SELECT</b><br> 
	Cette structure de contrôle permet de sélectionnr un bloc d'instruction en fonction de la valeur d'une expression. Contrairement au
	<i>switch</i> du langage 'C' l'exécution d'un bloc se termine au prochain <b>CASE</b> sans besoin de mettre un <i>break</i>.
	<pre><code>example:
	select case jstick()
	case 1 ' bouton du joystick enfoncé
	   bye
	case 2 ' levier à droite
	  move_right()
	case 4 ' levier vers la gauche
	  move_left()
	case 8 ' levier vers le bas
	  move_down()
	case 16 ' levier vers le haut
	  move_up()
	end select
	REM contrôle du mouvement d'un sprite à l'écran à l'aide du joystick     
	  </code></pre></li>
	<li><b>SETPIXEL(x,y,color)</b><br>
	Colore le pixel à la coordonnée <i>{x,y}</i> avec la couleur <i>color</i>.
	<pre><code>example:
	setpixel(10,20,4) ' le pixel à la postion {10,20} prend la valeur 4
	</code></pre></li>  
	<li><b>SETTMR(<i>expr</i>)</b><br>
	Initialise la minuterie de pause sans bloquer l'exécution. À utiliser avec la fonction
	<a href="#timeout">TIMEOUT</a>
	<pre><code>example:
    DIM count
    settmr(100) ' minuterie initialisée à 100 millisecondes.
    while not timeout()
      rem combien de WHILE par seconde?
      count=count+1
    wend
    print "boucle WHILE par seconde: ",10*count
	  </code></pre></li>
	<li><b>SHL(<i>expr</i>)</b><br>
	Décale vers la gauche <i>expr</i> de 1 bit (multiplication par 2).
	<pre><code>example:
	&gt;? shl(4)
	8
	&gt;|</code></pre></li>
	<li><b>SHR(<i>expr</i></b><br>
	Décale vers la droite <i>expr</i> de 1 bit (division par 2).
	<pre><code>example:
	&gt;? shr(-9)
	-5 
	&gt; REM pensiez-vous que ça donnait -4 ?
	&gt;|</code></pre></li> 
    <li><a name="sleep"></a><b>SLEEP(<i>expr</i>)</b><br>
    Suspend l'exécution du programme pour une durée en millisecondes égale à la valeur de <i>expr</i>.
    <div>exemple:
    <pre><code>
    &gt;sleep(1000)
    
    &gt;_
    </code></pre>
    L'invite de commande va réapparaître après 1 seconde.
    </div>
	<div><a href="#index">index</a></div>
    </li>
	<div class="item_div"></div>
	<li><b>SPRITE(x,y,width,height,@var#)</b><br>
	fonction qui affiche un sprite à l'écran. Cette fonction retourne une
	valeur booléenne qui indique si le sprite est entré en collision avec un autre objet.
	<ul>
		<li><b>{x,y}</b> Coordonnées du coin supérieur gauche du sprite.</li>
		<li><b>width</b> Largeur du sprite en pixels.</li>
		<li><b>height</b> Hauteur du sprite en pixels.</li>
		<li><b>var#</b> Nom de la variable tableau d'octets qui contient le sprite. Cette variable doit-être passée par 
		référence comme indiqué par le caractère <b>'@'</b>.</li>
	</ul>
	<pre><code>example:
	dim cross#(8)=($0f,$f0,$ff,$ff,$ff,$ff,$0f,$f0) 'petite croix de 4x4 pixels
	if sprite(56,24,4,4,@cross#) then ? "collision" end if
	</code></pre>
	Les sprites sont affichés à l'écran en utilisant une fonction XOR (OU exclusif) pixel à pixel. Cette méthode 2 avantages.
	Le premier est qu'elle permet de détecter les collisions en supposant que le fond d'écran est noir (0). Le deuxième est qu'il
	suffit de réafficher le sprite par dessus lui-même pour l'effacer. la méthode pour déplacer un sprite à l'écran est la suivante:
	<pre><code>
	while 1
	  collision=sprite(x,y,8,8,@spr#) ' affiche un sprite de 8x8 pixels
	  pause(10) ' pause de 10 millisecondes, cette valeur n'est pas critique peut-être 20 msec.
	  sprite(x,y,8,8,@spr#) 'efface le sprite
	  ' ici on peut mettre du code pour gérer les collisions
	  '...
	  select case jstick() 'lecture du joystick et déplacement dans la direction indiquée.
	  case 1 ' bouton enfoncé
	    cls
	    bye
	  case 16 'vers le haut
	    if y&gt;0 then y=y-1 end if
	  case 8 'vers le bas
	    if y&lt;170-8 then y=y+1 end if
	  case 2 'vers la droite
	    if x&lt;240-8 then x=x+1 end if
	  case 4 ' vers la gauche
	    if x&gt;0 then x=x-1 end if
	  ' on peut ajouter des CASE pour gérer les 4 directions diagonales.
	  '...  
	  end select  
	wend   
	</code></pre>
	</li> 
	<li><b>SRCLEAR(<i>expr</i>)</b><br>
	Cette commande efface le contenu de la mémoire SPI RAM. <i>expr</i> est le nombre d'octets à effacer. L'effacement se fait 
	toujours à partir de l'adresse 0.
	<pre><code>example:
	srclear(1000) ' efface les 1000 premiers octets de la mémoire SPI RAM.</code></pre></li>
	<li><b>SRLOAD <i>"file_name"</i></b><br>
	<b>SRLOAD <i>var$</i></b><br>
	Il s'agit d'une fonction qui charge en mémoire SPI RAM le contenu d'un fichier. Le chargement débute à l'adresse 0.
	La taille maximale est de 65535 octets. La fonction retourne le nombre d'octets chargés.
	<pre><code>example:
	size=srload "test.spr" ' charge le fichier <i>test.spr</i> et retourne sa grandeur dans <i>size</i>.</code></pre></li>
	<li><b>SRREAD(<i>adr</i>,@var,<i>size</i>)</b><br>
	Lecture d'un bloc d'octets de la SPI RAM dans une variable.
	<ul><li><b>adr</b> adresse SPI ou doit débuter la lecture.</li>
	<li><b>var</b> nom de la variable dans laquelle les valeurs lues seront copiées. Cette variable doit-être passée par
	référence comme l'indique le caractère <b>'@'</b>.
	<li><b>size</b> nombre d'octets à lire.</li>
	<pre><code>example:
	DIM i, spr#(32)
	srread(0,@i,2) ' lit un entier et le met dans la variable <i>i</i>.
	srread(4,@spr#,32) ' lit un bloc de <i>32</i> octets à partir de l'adresse <i>4</i> dans le tableau <i>spr#</i>
	</code></pre>
	</li>
	</ul>
	<li><b>SRSAVE <i>"file_name"</i>, <i>size</i></b><br>
	<b>SRSAVE <i>var$</i>, <i>size</i></b><br>
	Sauvegarde dans un fichier le contenu de la mémoire SPI RAM. La sauvegarde se fait à partir de l'adresse 0.<br>
	<ul>
	<li><b>file_name|var$</b> Nom du fichier de sauvegarde.</li>
	<li><b>size</b> Nombre d'octets à sauvegarder.</li></ul>
	<pre><code>example:
	srsave "test.dat", 1024 ' sauvegarde <i>1024 octets</i> dans le fichier <i>test.dat</i></code></pre>
	</li>
	<li><b>SRWRITE(<i>adr,@var,size</i>)</b><br>
	Copie le contenu d'une variable dans la mémoire SPI RAM.<br>
	<ul>
	<li><b>adr</b> adresse destination dans la SPI RAM.</li>
	<li><b>var</b> nom de la variable qui contient les données à transférer dans la SPI RAM. Cette variable est passée par référence
	comme indiqué par le caractère <b>'@'</b>.</li>
	<li><b>size</b> nombre d'octets à copier.</li>
	</ul>
	<pre><code>example:
	DIM i, spr#(32)
	srwrite(0,@i,2) ' écrit  l'entier <i>i</i> dans la SPI RAM à l'adresse 0.
	srwrite(4,@spr#,32) ' écris un bloc de <i>32</i> octets à l'adresse <i>4</i> à partir du tableau <i>spr#</i>
	</code></pre>
	</li>
	<li><a name="sub"></a><b>SUB name([<i>arg_list</i>])</b><br>
	[<b>LOCAL</b> <i>var_list</i>]<br>
	<i>block</i><br>
	[if <i>log_expr<i> then </i></i><b>EXIT SUB</b> end if<br>
	<i>block</i>]<br>
	<b>END SUB</b><br>
	Cette déclaration sert à définir une sous-routine. La liste des variables locales, s'il y en a, doit-être énumérée au début.
	<b>EXIT SUB</b> peut-être utilisé pour sortir de la sous-routine si une certaine condition est remplie.
	<pre><code>example:
	sub box_madness() ' dessine des boites au hasard
	  local x,y,w,h,c
	  while not key() ' arrête lorsqu'une touche est enfoncée.
	    x=abs(rnd())%240
	    y=abs(rnd())%170
	    w=abs(rnd())%240
	    h=abs(rnd())%170
	    c=abs(rnd())%16
	    box(x,y,w,h,c)
	  wend
	end sub
	</code></pre>
	</li>
	<li><b>THEN</b><br>
	Voir <a href="#if">IF</a></li>
	<li><b>TICKS()</b><br>
	 PV16SOG possède un compteur interne qui est incrémenté à chaque milliseconde. Cette fonction retourne la valeur de ce compteur.
	 Ce compteur de 16 bits retourne à zéro à intervalle d'environ 65 secondes.
	 <pre><code>example:
	 REM utilisation du compteur interne pour mesurer un interval de temps.
	 t0=ticks()
	 for i=0 to 10000
	 next i
	 ? "temps écoulé pour 10000 itération FOR ", ticks()-t0
	 </code></pre>
	 </li>
	 <li><b>TIMEOUT()</b><br>
	 Cett fonction vérifie la valeur de la minuterie de pause et retourne vrai si elle est expirée.
	 <pre><code>example:
	 settmr(1000)
	 while not timeout()
	   ? "pas encore expiree"
	 wend
	 </code></pre>
	 </li>
	 <li><b>TONE(<i>note,msec,wait</i>)</b><br>
	 Fait entendre une note de la gamme tempérée.
	 <ul>
		 <li><b>note</b> note de la gamme dans l'intervalle {0-47}. <b>0</b> correspond à DO2# et <b>47</b> à DO6. L'étendu est de 4 octaves. On peut
		 utiliser un nombre négatif pour faire une pause.</li>
		 <li><b>msec</b> durée de la note en millisecondes.</li>
		 <li><b>wait</b> Si cette valeur vaut <b>0</b> l'exécution du programme se poursuit pendant l'exécution de cette note. Autrement le programme
		 attend la fin de la note avant de poursuivre.</li>
	 </ul>
	 <pre><code>example:
	 REM ce programme joue les 5 premières notes
	 REM du thème musical du film rencontre du 3ième type.
	 dim ce3k#(10)=(13,200,15,200,11,200,1,200,6,200)
	 for i=1 to ubound(ce3k#) step 2
	     tone(ce3k#(i)+12,3*ce3k#(i+1),1)
	 next i
	 </code></pre>
	 </li>
	 <li><b>TRACE(0|1)</b><br>
	 C'est un outil de débogage des programmes BASIC pour les utilisateurs avancés. 
	 Pour l'utiliser il faut connaître le fonctionnement de la machine virtuelle et ses
	 <a href="./stackvm.html#opcoddes">opcodes</a>.<br>
	 la commande <b>trace(1)</b> active le mode trace et <b>trace(0)</b> le désactive. Le mode trace exécute le programme pas à pas et affiche
	 après chaque instruction de la machine virtuelle le contenu de la pile des arguments ainsi que le nombre
	 d'éléments sur la pile des retours. La touche <b>ESC</b> permet de quitter le mode trace, toute autre touche exécute le code machine
	 suivant et revient à pause.  La mode peut-être activé/désactivé n'importe où dans le programme. L'état de l'écran est sauvegarder dans 
	 la RAM SPI avant que les informations de traçage soit affichée et l'écran est restauré avant de continuer l'exécution. Pour plus 
	 d'information consultez le document <a href="./stackvm.html">stackvm.html</a>
	 <pre><code>example:
	 REM activation conditionnelle de trace
	 for i=1 to 100
	   if (i=50) then trace(1) end if
	   ? i
	 next i
	 
	 
	 REM information qui vont apparaître 
	 REM à l'écran de traçage lors de l'activation
     
     28
     R:2
     1 : 31726	 
     
     ' 28 est le dernier opcode exécuté et correspond à l'intruction <b>LIT</b>
     ' R:2 signifit qu'il y a 2 éléments sur la pile <b>rstack</b>
     ' 1 : 31726  signifit qu'il y a 1 élément sur la pile des arguments
     '           31726 est la valeur de cet argument. Il s'agit d'un pointeur
     '           sur la variable <i>i</i> qui va être imprimé par l'instrution
     '           suivante.
	 </code></pre></li>
	 <li><b>UBOUND(<i>var</i>)</b><br>
	 Cette fonction retourne la valeur du dernier indice d'une variable tableau.
	 <pre><code>example:
	 &gt;dim vector(100)
	 &gt;? ubound(vector)
	 100
	 &gt;|
	 </code>
	 </pre></li>
	 <li><b>USE "<i>file</i>"</b><br>
	 Cette directive sert à compiler un fichier BASIC utilisé par le fichier principal. <i>file</i> est le nom du fichier à inclure. 
	 Il doit s'agir d'un fichier existant sur la carte SD. Un fichier inclus peut aussi utiliser la directive <b>USE</b> 
	 jusqu'à un niveau d'imbrication de 4. 4 étant le nombre maximal de fichiers pouvant-être ouvert simultanément.
	 <pre><code>example:
	 use "joystick.inc" ' fichier définissant des constantes pour le joystick
	 use "lem.spr"      ' fichier définissant un sprite appellé LEM.
	 ' code du programme principal
	 .
	 .
	 .
	 </code></pre>
	 </li>
	 <li><b>video(<i>expr</i>)</b><br>
	 Si <i>expr</i> est évaluée à <b>0</b> la sortie vidéo est désactivée autre elle est activée.  La sortie vidéo accapare le plus grand
	 nombre de cycles du CPU. La désactivation de la sortie vidéo permet d'accélérer une sous-routine.
	 <pre><code>example:
	 sub test(n)
	 local t0
	   cls
	   if n then 'rapide
	     t0=ticks()
	     video(0)
	     box(0,0,240,170,4)
	     video(1)
	     ? ticks()-t0, "msec"
	   else 'lent
	     t0=ticks()
	     box(0,0,240,170,4)
	     ? ticks()-t0, "msec"
	   end if
	 end sub
	 
	 &gt; test(0)
	 55 msec
	 &gt; test(1)
	 32 msec
	 </code></pre></li>
	 <li><b>WAITKEY()</b><br>
	 Cette fonction attend que l'utilisateur enfonce une touche au clavier et retourne la valeur de cette touche.
	 <pre><code>example:
	 &gt;putc waitkey()
	 r
	 &gt;|
	 REM l'utilisateur a enfoncé la touche 'r'</code></pre></li>
	 <li><b>WHILE <i>log_expr</i></b><br>
	 [<i>block</i>]<br>
	 <b>WEND</b><br>
	 La structure de contrôle <b>WHILE</b> exécute le bloc d'instructions <i>block</i> terminé par le <b>WEND</b> tant que <i>log_expr</i>
	 retourne vrai.<br>
	 <pre><code>example:
	 dim i=0
	 while i<100
	   ? i
	   i=i+1
	 wend
	 0
	 1
	 2
	 ...
	 99
	 </code></pre>
	 </li>
	</ul>
</p>
<h3><a name="examples">Examples de programmes</a></h3>
<p>
</p>
<hr width="50%" align="center">
<h2>INDEX</h2>
<p>
	<ul>
		<li><a href="./index.html">Introduction</a></li>
		<li><a href="./vpc32vga.html">Description du VPC-32V</a></li>
		<li><a href="./shell.html">shell du VPC-32V</a></li>
		<li><a href="./editor.html">Éditeur du VPC-32V</a></li>
        <li><a href="./BASIC.html">BASIC du VPC-32V</a></li>
        <li><a href="./stackvm.html">machine virtuelle du VPC-32V</a></li>
	</ul>
</p>

</body>
</html>
